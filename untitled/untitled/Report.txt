Class Design Report

In this project, the goal was to design a flexible and modular class structure for a simple fantasy game. The game features characters of different races, items that can be equipped, and a game board on which players and enemies interact. The design ensures easy extensibility, safe memory management, and seamless support for core gameplay mechanics such as combat, item handling, and board representation.

1. Square Class

The Square class represents a single tile on the game board.

A square can contain three things:

• an enemy
• an item
• the player

Used shared_ptr for all of these because the board shouldn’t “own” the characters or items permanently—multiple systems might reference them. The square just needs safe access to them, and smart pointers handle cleanup automatically.
One of Square’s responsibilities is simply to report what is present. The printInfo() method checks each pointer and prints the right message. If nothing is in the square, it tells us the square is empty. It’s basically the “container” class for in-game objects.

2. Board Class

The Board is a 2D grid made of Squares.Used a vector<vector<shared_ptr<Square>>> because vectors are easy to resize and handle dynamic memory for us. Each square on the board is created with make_shared<Square>() so the board doesn’t worry about deleting them later.

The board’s job is:

• to create the grid
• to display the grid visually using ASCII characters
• to place items and enemies on it (in the populateBoard function)

The display logic was designed to be simple and readable, using symbols such as:

• # = player
• * = enemy
• + = item
• space = empty

The Board class doesn’t actually control gameplay; it just represents the environment.


3. Item Class Hierarchy

The Item class is the base for all equipment. Every item has a name and weight. From there, built four item types:

• Weapon (adds attack power)
• Armour (adds defence, might reduce attack)
• Shield (works like armour but thematically different)
• Ring (can modify strength or health, and characters can wear multiple)

All of these override print() to show their own stats. In the game, items are picked up, equipped, and can change the character's total attributes. Inheritance was chosen because each item shares core behaviour (name + weight) but adds its own stats. Rings are special because they can stack, so I used a vector<shared_ptr<Ring>> instead of a single slot.


4. Character Class and Races

The Character class is the biggest part of the design. It’s an abstract base class because every race prints stats a bit differently and may have different combat behaviours. The Character stores:

• base stats (attack, defence, health, strength, and their chances)
• equipped items (weapon, armour, shield, rings)
• an inventory list
• functions for calculating “total” stats with equipment added

The pickUp() method is fairly involved: it first checks if the character is strong enough to carry the item, then figures out what type of item it is, equips it, and prints information. This is where polymorphism and dynamic_pointer_cast really matter.

To implement distinct race behaviour several derived classes were created:

• Human
• Elf
• Dwarf
• Hobbit
• Orc

Each race has its own base stats and its own version of printStats(). The Orc class is special because its stats change depending on whether it’s day or night, so I added a boolean flag and a method setTimeOfDay() to update the numbers. This setup makes it easy to add more races later, since all that’s needed is another class that extends Character.


5. Overall Design Notes

The project follows a clean object-oriented style:

• Composition: The Board contains Squares; Squares contain characters and items.
• Inheritance: Item → Weapon / Armour / Shield / Ring
               Character → Human / Elf / Dwarf / Hobbit / Orc
• Polymorphism: printStats() and print() are virtual, allowing race-specific and item-specific behaviour.
• Memory Safety: Smart pointers (shared_ptr) are used everywhere items and characters are passed around.
• Extensibility: New items, races, or board features can be added without altering existing class logic too much.


Conclusion

Overall, the system is designed to feel like a small but functional game engine. The Board controls the environment, the Square represents spaces on the board, Characters hold equipment and stats, and Items modify those stats. By splitting responsibilities across well-defined classes and using inheritance for things that share behaviour, the code remains clean, readable, and easy to expand.



